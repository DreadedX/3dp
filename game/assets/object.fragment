#version 330 core
struct Material {
	sampler2D diffuse;
	sampler2D normal;
	sampler2D specular;
	float shininess;
};

struct Light {
	vec3 direction;

	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};

in VS_OUT {
	vec3 FragPosition;
	vec2 Texcoord;
	vec3 Normal;
} fs_in;

layout (location = 0) out vec4 outColor;

uniform Material material;
uniform Light light;
uniform vec3 viewPosition;

// This is currently used to enable two pass rendering
uniform bool toggle;

const float kPi = 3.14159265;
const float kShininess = 16.0;

void main() {

	// if (toggle) {
		float energyConservation = (8.0 + material.shininess) / (8.0 * kPi);

		vec4 color = texture(material.diffuse, fs_in.Texcoord);

		if (color.a < 1.0 && toggle) {
			discard;
		}

		if ((color.a == 1.0 || color.a == 0.0) && !toggle) {
			discard;
		}

		// Ambient
		vec4 ambient = vec4(light.ambient, 1.0) * color;

		// Diffuse
		vec3 norm = normalize(fs_in.Normal);
		vec3 lightDir = normalize(-light.direction);
		float diff = max(dot(norm, lightDir), 0.0);
		vec4 diffuse = vec4(light.diffuse, 1.0) * diff * color;

		// Specular
		vec3 viewDir = normalize(viewPosition - fs_in.FragPosition);
		vec3 halfwayDir = normalize(lightDir + viewDir);
		float spec = energyConservation * pow(max(dot(norm, halfwayDir), 0.0), material.shininess);
		//vec4 specular = vec4(light.specular, 1.0) * spec * texture(material.specular, fs_in.Texcoord);
		vec4 specular = vec4(light.specular, 1.0) * spec * texture(material.specular, fs_in.Texcoord);

		outColor = vec4((ambient + diffuse + specular).rgb, 1.0);
		//outColor = vec4(ambient + diffuse, 1.0);
	// } else {
    //
	// 	outColor = texture(material.diffuse, fs_in.Texcoord);
	// 	if (outColor.a == 1.0) {
	// 		discard;
	// 	}
	// }

	// Gamma correction
	float gamma = 2.2;
	outColor.rgb = pow(outColor.rgb, vec3(1.0/gamma));
}
